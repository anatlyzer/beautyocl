-- @path EMF=/beautyocl.catalogue.emfocl/metamodels/OCLEcore.ecore
-- @path WRAP=/beautyocl.catalogue.emfocl/metamodels/emfocl_typing_wrapper.ecore
-- @path ACT=/beautyocl.actions/model/actions.ecore
-- @pre OCL!OperationCallExp.allInstances()->forAll(op | op.name = 'oclIsKindOf' implies self.arguments->size() = 1 )
module simplify_if_kindof;
create OUT : ACT from IN : EMF, IN2 : WRAP;

helper context EMF!OperationCallExp def: argument : OclAny = self.arguments->first();

helper  def: typ : WRAP!TypWrapper = WRAP!TypWrapper.allInstances()->first();

helper context EMF!OCLExpression def: isKindOf() : Boolean = false;

-- -- @ignore undefined-value
helper context EMF!OperationCallExp def: isKindOf() : Boolean = if ( self.name = 'oclIsKindOf' ) then
	thisModule.typ.isSameType(self.source, self.arguments->first())
else
	false
endif;

rule removeIf {
   from o : EMF!"ecore::IfExp"
     to a : ACT!Replace
do {
   a.source <- o;
   a.target <- o.thenExpression;
}
}

helper context EMF!OperationCallExp def: OperatorCallExp__filter__ : OclAny = Set {'not', 'and', 'or', '<', '>', '>=', '<=', '+', '-', '*' }->includes(self.name);

helper context EMF!OperationCallExp def: BinaryOperatorCallExp__filter__ : OclAny = Set {'not', 'and', 'or', '<', '>', '>=', '<=', '+', '-', '*' }->includes(self.name) and self.arguments->notEmpty();

helper context EMF!OperationCallExp def: UnaryOperatorCallExp__filter__ : OclAny = Set {'not', 'and', 'or', '<', '>', '>=', '<=', '+', '-', '*' }->includes(self.name) and self.arguments->isEmpty();

