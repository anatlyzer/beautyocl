-- @path OCL=/beautyocl.catalogue.simplifications/metamodels/superimposed.ecore
-- @path TYP=/beautyocl.catalogue.simplifications/metamodels/typing.ecore
-- @path ACT=/beautyocl.actions/model/actions.ecore

-- This simplification identifies a chain of "or" expressions
-- checking the type of same source variable with oclIsKindOf.
-- If the chain covers all the subtypes of a type, it is substituted by the type.
-- 
--    v.oclIsKindOf(A) or v.oclIsKindOf(B) or v.oclIsKindOf(C) => or v.oclIsKindOf(SuperTypeOfABC)
-- 
--
-- The following pre-conditions hold:
--
-- @pre OCL!OperationCallExp.allInstances()->forAll(op | op.name = 'oclIsKindOf' implies self.arguments->size() = 1 )
--
module "simplify_full_type_comparison";
create OUT : ACT from IN : OCL, IN2 : TYP; 

helper def : typ : TYP!ExprTyping = TYP!ExprTyping.allInstances()->first();


helper  def: findSuperType(param : Set(OCL!"OclType")) : OclAny = OclUndefined;
	

-- @force-declared-return-type
-- @ignore found-in-subtype 
--         because isOrKindOf already checks that it is either BinaryOp or OperationCallExp
helper context OCL!BinaryOperatorCallExp def: orKindOfCheckedTypes : Set(OCL!"OclType") =
	self.source.orKindOfCheckedTypes->union(self.argument.orKindOfCheckedTypes);

helper context OCL!OperationCallExp def: isKindOf() : Set(OCL!"OclType") =
	Set { self.arguments->first().oclAsType(OCL!"OclType") };

-- isOrKindOf
helper context OCL!OclExpression         def: isOrKindOf : Boolean = false;
helper context OCL!OperationCallExp      def: isOrKindOf : Boolean =
	self.name = 'oclIsKindOf';
helper context OCL!BinaryOperatorCallExp def: isOrKindOf : Boolean =
	self.name = 'or' and self.source.isOrKindOf and self.argument.isOrKindOf;
	
rule removeIf {
	from o : OCL!BinaryOperatorCallExp ( 
		if o.isOrKindOf and not o.refImmediateComposite().isOrKindOf then
			thisModule.findSuperType(o.orKindOfCheckedTypes) <> OclUndefined
		else
			false
		endif
	)
	to a : ACT!Replace
	do {
		a.source <- o;
		a.target <- o.thenExpression;
	}
}

