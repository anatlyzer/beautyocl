
-- @path OCL=/beautyocl.catalogue.simplifications/metamodels/superimposed.ecore
-- @path OCLt=/beautyocl.catalogue.simplifications/metamodels/superimposed.ecore
-- @path ACT=/beautyocl.actions/model/actions.ecore
-- @path COMP=/beautyocl.catalogue.simplifications/metamodels/comparison.ecore
-- @path TYP=/beautyocl.catalogue.simplifications/metamodels/typing.ecore

module "unshort";
create OUT : ACT, OUT2 : OCLt from IN : OCL, IN2 : TYP, IN3 : COMP; 

helper def : comp : COMP!ExprComparator = COMP!ExprComparator.allInstances()->first();
helper def : typ  : TYP!ExprTyping = TYP!ExprTyping.allInstances()->first();

helper context OclAny def: oclAsType(t : OCL!"OclType") : OclAny = self;

helper context OCL!BooleanExp    def: isBooleanExpr(b : Boolean) : Boolean = self.booleanSymbol = b;
helper context OCL!OclExpression def: isBooleanExpr(b : Boolean) : Boolean = false;

-- CHECK FOR <> OclUndefined
helper context OCL!OclExpression def: hasShortThing() : Boolean = false;
helper context OCL!PropertyCallExp def: hasShortThing() : Boolean = self.source.hasShortThing();
helper context OCL!OperationCallExp def: hasShortThing() : Boolean = 
	if self.name = 'oclIsKindOf' or self.name = 'oclIsUndefined' then
		true
	else
		self.source.hasShortThing()
	endif;


helper context OCL!OclExpression def: kindOfType() : TupleType(source : OCL!OclExpression, type : TYP!CClass) =
	if self.oclIsKindOf(OCL!OperationCallExp) then
		if self.name = 'oclIsKindOf' then -- TODO: Check typeOf
			Tuple { source = self.source, type = thisModule.typ.typeOf(self.arguments->first()).oclAsType(TYP!CClass) }
		else 
			OclUndefined	
		endif
	else
		OclUndefined
	endif;

-- Computes all ocurrences of a given sub-expr in the current expression, and for each of these
-- subexpressions returns its type.
--
-- TODO: Consider more subtypes of Expression!
helper context OCL!OclExpression def: allUsages(subExpr : OCL!OclExpression) : Set(TYP!CClass) = 
	Set { };
helper context OCL!PropertyCallExp def: allUsages(subExpr : OCL!OclExpression) : Set(TYP!CClass) = 
	if thisModule.comp.isSameExpr(self.source, subExpr) then
		let c : TYP!CClass = thisModule.typ.accessType(self) in
		if c <> OclUndefined then
			Set { c }
		else
			Set { }
		endif	
	else
		Set { }
	endif;
	
helper def: checkUnshortCondition(outerExp : OCL!OclExpression, inner : OCL!OclExpression) : Boolean = 
	let outer: TupleType(source : OCL!OclExpression, type : TYP!CClass) = outerExp.kindOfType() 
	in if outer <> OclUndefined then
		let innerUsages : Set(TYP!CClass) = inner.allUsages(outer.source) 
		in innerUsages->forAll(c | c.superClasses->includes(outer.type) )
	   else false endif	
	;


--
-- if exp then exp else true endif => true
--
-- @ignore invalid-assignment-imperative-binding
rule unshortCircuit {
	from i : OCL!IfExp (
		if i.thenExpression.oclIsKindOf(OCL!IfExp) then
			if thisModule.checkUnshortCondition(i.condition, i.thenExpression.condition) 
				-- The other case is not to have any kind of checking (oclIsKind, OclUndefined, etc.)
				or (not i.condition.hasShortThing())
			then
				thisModule.comp.isSameExpr(i.elseExpression, i.thenExpression.elseExpression)
			else
				false
			endif
		else
			false
		endif 
	)
	to c : ACT!CompositeAction (
			actions <- Sequence { a, s1, s2, s3, s4, s5 }
	   ),	
	   a : ACT!Replace, 
	   s1 : ACT!"SetP", s2 : ACT!"SetP", s3 : ACT!"SetP", s4 : ACT!"SetP", s5 : ACT!"SetP",
		-- Should be BinaryOperator??
	   r : OCLt!OperatorCallExp (
			name <- 'and'
	   ),
	   newIf : OCLt!IfExp (
			--s1: -- condition <- r
			--, AnATLyzer should raise an invalid assignment error!
			--s2: --thenExpression <- i.thenExpression.thenExpression,
			--s3: --elseExpression <- i.thenExpression.elseExpression
	   )
	do {
		c.source <- i;
		
		s1.source <- newIf;
		s2.source <- newIf;
		s3.source <- newIf;
		
		s1.value <- r;
		s2.value <- i.thenExpression.thenExpression;
		s3.value <- i.thenExpression.elseExpression;

		s1.propertyName <- 'condition';
		s2.propertyName <- 'thenExpression';
		s3.propertyName <- 'elseExpression';
		
		
		-- s4 -- r.source <- i.condition;
		-- s5 -- r.arguments <- i.thenExpression.condition;
		s4.source <- r;
		s5.source <- r;
		
		s4.value <- i.condition;
		s5.value <- i.thenExpression.condition;
		
		s4.propertyName <- 'source';
		s5.propertyName <- 'arguments';
		
		a.source <- i;
		a.target <- newIf;
	}
}

